---
title: Blockchain 기술 학습 정리 자료2
date: 2022-02-12 13:12:54
tags:
  - Blockchain
categories:
  - Blockchain
---

## 합의 모델 (합의 알고리즘)

- 블록체인 네트워크 기술의 핵심은 다음 블록을 게시할 사용자를 결정하는 것이다. 이는 합의 모델 중 하나를 구현하여 해결한다.
- 예를 들어, 무허가 블록체인 네트워크의 경우에는 일반적으로 다음 블록을 게시하기 위해 동시에 경쟁하는 많은 게시 노드가 있다. (수수료를 얻기 위해)
- 이러한 상황에서 사용자가 다른 사용자가 게시하려는 블록을 전파하는 이유와 여러 노드가 거의 동시에 블록을 게시할 때 충돌을 해결해야 한다.

### 기본적인 해결 방법

- 사용자가 블록체인 네트워크에 가입한다는 것은 시스템의 초기 상태에 동의하는 것이다. 이것은 사전에 구성된 유일한 블록에 기록된다.
- 제네시스 블록(가장 처음의 블록)이 있으며, 합의된 합의 모델에 따라 모든 블록이 그 이후에 블록에 추가(연결)된다. 그러나 모델과 관계 없이 각 블록은 유효해야 하므로, 각 블록체인 네트워크의 사용자가 독립적으로 이를 검증할 수 있다.
- 초기 상태와 이후 모든 블록을 검증하는 기능을 결합하여 사용자는 블록체인의 현재 상태에 대해 독립적으로 동의할 수 있다.
- 기본적으로 매커니즘은 더 긴 블록체인을 올바른 것으로 간주하여 채택한다. 이는 가장 많은 작업을 투입했기 때문에 신뢰성이 있다고 판단한다.
- 블록체인에 새 블록을 추가하려면 모든 노드가 시간이 지남에 따라 공통된 합의에 도달하여야 한다. 그러나 일시적인 의견 차이는 허용한다. (악의적인 공격자가 있는 경우에도 작동하여야 한다.)

### 작업 증명(PoW) 합의 모델

- 퍼즐을 푸는 것은 매우 어렵지만, 정답이 맞는지 확인하는 과정을 매우 쉽도록 설계되어 있다. 이를 통해 다른 모든 전체 노드는 제안된 다음 블록을 쉽게 검증할 수 있으며, 충족하지 않은 블록은 거부한다.
- 일반적으로 퍼즐 방법은 블록 헤더의 해시 다이제스트가 목표 값보다 작도록 요구하는 것이다. 이를 위해 nonce 값을 변경하며 해시를 계산한다.
- 각각의 블록은 독립적이기 때문에 유효한 블록을 수신한다면, 그 즉시 현재 작업을 버리고 새로 수신된 블록을 검증 및 구축한다.

```
SHA256(“blockchain” + Nonce) = Hash Digest starting with “000000”
```

- 퍼블리싱 노드가 이 작업을 수행하고, 유효한 nonce가 포함된 블록을 네트워크의 전체 노드로 보낸다. 수신자인 전체 노드는 새 블록이 퍼즐 요구사항을 충족하였는지 확인한 다음, 블록을 자신의 블록체인 사본에 추가하고, 피어 노드로 보낸다. 이를 통해 새 블록은 네트워크 전체에 배포된다.

### 지분 증명(PoS) 합의 모델

- 사용자가 시스템에 더 많은 지분을 투자하고 있을수록 시스템이 성공하기를 원할 가능성이 높고, 시스템을 전복시키고 싶어할 가능성이 적다는 아이디어를 기반으로 한다. Stake는 블록체인 네트워크의 사용자가 시스템에 투자한 암호화폐의 양이다. 일단 스테이킹되면 암호화폐는 일반적으로 더 이상 사용할 수 없다.
- 블록체인 네트워크의 사용자가 새 블록을 게시할 가능성은 전체 블록체인 네트워크 스테이킹된 암호화폐의 양에 대한 지분의 비율과 관련이 있다.
- 작업 증명에서 볼 수 있는 리소스 집약적인 계산이 필요없다. 그러므로 채굴마다 새로운 암호화폐가 생성되는 것이 아니라, 모든 화폐는 이미 사용자에게 배포되어 있으며, 블록 발행에 대한 보상은 일반적으로 사용자가 제공한 거래 수수료를 얻는 것이다.

### 라운드 로빈 합의 모델

- 일부 허가된 블록체인 네트워크에서 사용하는 방식이다.
- 노드는 교대로 블록을 생성하며, 개시 노드가 블록을 게시할 수 없는 상황을 처리하기 위해 사용 가능한 노드가 블록 게시를 중단하지 않도록하는 시간 제한 기법이 포함될 수 있다.
- 노드 간의 신뢰가 필요하기 때문에 대부분의 암호화폐에서 사용하는 무허가 블록체인 네트워크에서는 적합하지 않다. 악성 노드가 지속적으로 노드를 추가하여 새 블록을 게시할 확률을 높일 수 있기 때문이다.

### 권한 증명 / 신원 증명 합의 모델

- 실제 ID에 대해 알려진 링크를 통해 게시 노드의 부분적인 신뢰에 의존한다. 게시 노드는 네트워크 내에서 신원이 입증되고 검증 가능해야 한다.
- 게시 노드가 새 블록을 게시하기 위해 ID/평판을 걸고 있다. 블록체인 네트워크 사용자는 게시 노드의 동작에 따라 게시 노드의 평판에 직접적인 영향을 준다. 게시 노드는 사용자가 동의하는 방식으로 행동하여 명성을 얻을 수 있는 것처럼, 블록체인 네트워크 사용자가 동의하지 않은 방식으로 행동하여 명성을 잃을 수도 있다. 평판이 낮을 수록 블록을 게시할 수 있는 가능성이 줄어든다.
- 높은 수준의 신뢰를 가진 허가된 블록채인 네트워크에만 적용할 수 있다.

### 경과 시간(PoET) 합의 모델

- 각 게시 노드는 컴퓨터 시스템 내의 보안 HW 시간 소스에서 대기 시간을 요청한다. 임의의 대기 시간을 생성하고 게시 노드는 임의의 시간을 갖고 해당 네트워크에서 유휴 상태가 된다. 게시 노드가 깨어나면 블록을 생성하고 블록체인 네트워크에 게시한다. 유휴 상태인 모든 게시 노드는 대기를 중지하고 전체 프로세스가 다시 시작한다.
- 이 모델은 대기 시간이 무작위로 선택되지 않은 경우 악의적인 게시 노드가 기본적으로 시스템을 지배하기 위해 최소한의 시간만 기다리므로 임의 시간이 사용되었는지 확인해야 한다.
- 검증되고 신뢰할 수 있는 SW는 이러한 보안 실행 환경에서 실행할 수 있으며, 외부 프로그램에 의해 변경될 수 있다.
- 게시 노드는 할당된 시간을 기다린 후 게시 노드가 무작위로 할당된 시간을 기다린 서명된 인증서를 요청할 수 있다. 그 다음 게시 노드는 블록과 함께 인증서를 게시한다.

## 원장 충돌 및 해결 방법

- 블록체인 네트워크에서 여러 블록이 거의 동시에 게시될 수 있다. 이로 인해 특정 시점에 서로 다른 버전의 블록체인이 존재할 수 있다. 블록체인 네트워크의 일관성을 유지하려면 이러한 문제를 신속하게 해결해야 한다.

```
• node_A creates block_n(A)with transactions #1, 2 and 3. node_A distributes it to some nodes.
• node_B creates block_n(B)with transactions #1, 2 and 4. node_B distributes it to some nodes.
• There is a conflict.
  o block_n will not be the same across the network.
    - block_n(A) contains transaction #3, but not transaction #4.
    - block_n(B) contains transaction #4, but not transaction #3.
```

<p align="center"><img src="/images/Blockchain/BasicStudy/BlockchainBasic2.JPG"></p>

<p align="center"><img src="/images/Blockchain/BasicStudy/BlockchainBasic3.JPG"></p>

- 일반적으로 대부분의 블록체인 네트워크는 다음 블록이 게시될 때까지 기다렸다가 해당 블록체인을 공식 블록체인으로 사용하여 장기 블록체인을 채택한다.
- 고아 블록(채택되지 못한 블록체인의 블록)에 있었던 모든 트랜잭션은 트랜잭션 풀(아직 블록에 포함되지 않은 트랜잭션이 있는 곳)으로 반환된다. 보류 중인 트랜잭션 집합은 아키텍쳐에 중앙 서버가 없기 때문에 각 노드에서 로컬로 유지 관리 된다.
- 블록을 덮어 쓸 가능성이 있기 때문에 관련 트랜잭션이 포함된 블록 위에 여러 개의 추가 블록이 생성될때까지 트랜잭션은 일반적으로 신뢰성 있는 것으로 수락되지 않는다. 개시된 블록 위에 빌드된 블록이 많을 수록 초기 블록을 덮어쓰지 않을 가능성이 높아진다.
- 매우 방대한 컴퓨팅 파워로 제네시스 블록에서부터 더 긴 체인을 만들어 기존의 체인을 지워버릴 수도 있지만, 사실상 불가능하며 이를 방지하기 위해 체크포인트를 생성하여 특정 블록 이전을 잠근다.

## 분기(포크, Forking)

- 블록체인 네트워크의 프로토콜 및 데이터 구조에 대한 변경이다. 일종의 블록체인 네트워크의 업데이트이다.
- 소프트 포크의 경우 업데이트되지 않은 노드와 호환되지만, 하드 포크의 경우 업데이트되지 않은 노드가 변경 후 블록을 거부하기 때문에 이전 버전과 호환되지 않는다.

### 소프트 포크

- 이전 버전과 호환되는 블록체인 구현에 대한 변경 사항이다.
- 소프트 포크의 예시 중 하나는 블록체인이 블록 크기를 줄이기로 결정한 경우이다. 업데이트 된 노드는 블록 크기를 조정하고 정상적으로 거래하며, 업데이트되지 않은 노드는 이러한 블록을 유효한 것으로 간주한다.

### 하드 포크

- 이전 버전과 호환되지 않는 블록체인 구현에 대한 변경이다.
- 모든 게시 노드는 업데이트 된 프로토콜을 사용하도록 전환해야 한다. 또한, 모든 노드는 새로 포맷된 블록을 거부하지 않도록 새 프로토콜로 업그레이드 해야 한다.
- 모든 활동이 새 체인으로 이동하면 두 체인이 호환되지 않기 때문에 이전 체인이 결국 사용되지 않을 수 있다.

### 암호화 변경 및 포크

- 블록체인 네트워크 내의 암호화 기술에서 결함이 발생한다면 결함의 중요성에 따라 하드 포크를 만드는 것이 유일한 해결책일 수 있다.

## 스마트 계약

- 계약 조건을 실행하는 컴퓨터화 된 거래 프로토콜이다.
- 스마트 계약의 일반적인 목표는 일반적인 계약 조건을 충족하고, 악의적이거나 우발적인 예외를 최소화하여 신뢰할 수 있는 중개자의 필요성을 최소화 하는 것이다.
- 스마트 계약은 블록체인 네트워크 내의 노드에 의해 실행된다.
- 블록체인 네트워크의 사용자는 스마트 계약이 제공하는 공공 기능에 데이터를 보내는 트랜잭션을 생성한다. 스마트 계약은 사용자가 제공한 데이터로 적절한 방법을 실행해서 서비스를 수행한다. 블록체인에 있는 코드는 변조 방지가 가능하므로 신뢰할 수 있는 제 3자로 사용할 수 있다.
- 스마트 계약은 계산을 수행하고, 정보를 저장하고, 공개적으로 노출된 상태를 반영하기 위해 속성을 노출하고, 적절한 경우 자동으로 다른 계정으로 자금을 보낸다. (반드시 재정적인 기능을 수행해야 하는 것은 아니다.)
- 스마트 계약은 입력이 주어지면 항상 해당 입력을 기반으로 동일한 출력을 생성한다는 점에서 결정적이여야 한다. 또한, 스마트 계약을 실행하는 모든 노드는 실행 후 얻은 새로운 상태에 동의해야 한다. 이를 달성하기 위해 스마트 계약은 직접 전달된 데이터 외의 데이터를 사용할 수 없다. (스마트 계약은 스마트 계약 내에서 웹 서비스 데이터를 가져올 수 없으며, 매개변수로 전달되어야 한다. 만약, 자체 시스템 컨텍스트 외부의 데이터를 사용하는 모든 스마트 계약은 '오라클'을 사용한다고 한다.)
- 블록체인 네트워크의 구현에서 게시 노드는 새 블록을 게시할 때 스마트 계약 코드를 동시에 실행한다. 스마트 계약이 활성화된 무허가 블록체인 네트워크의 경우에 스마트 계약에 트랜잭션을 발생하는 사용자는 코드 실행 비용을 지불해야 한다.
- 이 매커니즘은 스마트 계약 코드를 실행한 게시자에게 보상을 줄 뿐만이 아니라 악의적인 사용자가 배포한 다음 모든 리소스를 소비하여(무한 루프 등) 게시 노드에서 서비스 거부를 수행하는 스마트 계약에 엑세스하는 것을 방지한다.

## 블록체인 기술 기초 공부 참고문헌

- https://arxiv.org/abs/1906.11078
- https://www.youtube.com/watch?v=bBC-nXj3Ng4
